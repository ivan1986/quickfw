<?php
/**
 * HTML_MetaFormAction: process generated meta-information 
 * (see HTML_MetaForm), perform various (possibly custom) fields 
 * validation and detect used action.
 *
 * This class contains small number of validators. To extend it
 * you may derive this class or create plain PHP functions.
 * 
 * $Id: MetaFormAction.php 210 2007-07-02 11:23:03Z dk $
 */
require_once dirname(__FILE__).'/MetaForm.php';

class HTML_MetaFormAction
{
    /**
     * Errors generated by library. Error strings are hold in values of this array,
     * keys are internal and must not be used in application. You may use textual 
     * array values as input strings for gettext (for example). 
     */
    var $MFA_ERRORS = array(
        // Do not modify values in the future!
        'bad_form_action'          => 'Bad FORM "action" attribute: expected %s, got %s!',
        'non_existed_value'        => 'Field "%s" (%s) contains non-existed value(s): expected %s, got %s!',
        'invalid_value'            => 'Field "%s" (%s) contains invalid value: expected %s, got %s!',
        'validator_not_registered' => 'Validator %s is not registered!',
    );
    
    /**
     * @var string Name of 'dynamic' attribute.
     */
    var $MFA_ATTR_DYNAMIC = 'dynamic';
    
    /**
     * @var string Name of 'validator' attribute.
     */
    var $MFA_ATTR_VALIDATOR = 'validator';
    
    /**
     * @var string Name of 'manual' modifier.
     */
    var $MFA_MODIFIER_MANUAL = 'manual';
    
    /**
     * @var HTML_MetaForm HTML_MetaForm object (public property).
     */
    var $metaForm = null;
    
    /**
     * @var array List of errors collected during validations.
     */
    var $_mfa_errors = array();
    
    /**
     * @var function Function which will be caled by validationError().
     */
    var $_mfa_errorHandler = null;


    /**
     * Constructor. Create new HTML_MetaFormAction object.
     * POST data is NOT analyzed immediately; see process() method.
     * 
     * @param HTML_MetaForm $metaForm HTML_MetaForm object to use.
     * @param function $errorHandler Function which will be caled by validationError().
     */
    function HTML_MetaFormAction(&$metaForm, $errorHandler=null)
    {
        $this->metaForm =& $metaForm;
        $this->_mfa_errorHandler = $errorHandler;
    }
    
    
    /**
     * Process POST form calling all needed validators.
     * 
     * You may later call process() again with list of fields to check specified.
     * This case is very useful if your validators must be called conditionally,
     * depending of action button pressed of some other form checks. Just
     * specify meta:validator="vallidatorName:manual", and this validator will be
     * skipped on initial form processing, when process() called with no arguments.
     * 
     * This function may also generate more validation errors listed in $this->MFA_ERRORS.
     * 
     * @param array $fieldNames      List of field names to validate. By default - 
     *                               check all fields except marked as "manual".
     * @param string $defaultAction  Name of action to be used if there was no
     *                               POST form submitted yet. E.g., you may specify
     *                               here the value of some GET parameter holding
     *                               sub-action of the page. If null, 'INIT' used.
     * 
     * @return string  Return:
     *                 - 'INIT' if form is not submitted yet, page is just displayed
     *                 - 'UNKNOWN' if form is submitted without any SUBMIT button
     *                 - null if some validators failed
     *                 - [name of submit button] if validators succeeds and button is pressed 
     */
    function process($fieldNames = null, $defaultAction = null)
    {
        $metas = $this->metaForm->getFormMeta();
        if ($metas === null) {
            $lastError = $this->metaForm->getLastError();
            if ($lastError) {
                $this->validationError(null, $lastError);
                return null;
            }
            return $defaultAction === null? 'INIT' : $defaultAction;
        }

        // Check FORM action against REQUEST_URI. This is needed to exclude
        // ability to POST forms to some different script.
        if (!$this->_checkDynamicField(
            @$metas[$this->MFA_ATTR_DYNAMIC], $metas['original'],  // allowed values
            $this->metaForm->MF_REQUEST_URI,                       // got values 
            $this->MFA_ERRORS['bad_form_action'],                  // error message
            array(&$this->metaForm, '_getUriByUrl')                // allowed value modifier
        )) return null;
        
        // Get flat representation of metadata to allow scanning.
        $flat = $metas['items'];

        // Find active action (pressed Submit button).
        $action = 'UNKNOWN';
        foreach ($flat as $name => $meta) {
            if ($meta['type'] == 'action' && !empty($meta['value'])) {
                $action = $meta['name'];
                break;
            } 
        }
        
        $checkAllFields = false;
        if ($fieldNames === null) {
            $fieldNames = array_keys($flat);
            $checkAllFields = true;
        } else {
            $fieldNames = (array)$fieldNames;
        }
        
        // Process all form fields.
        $numErrors = 0;
        foreach ($fieldNames as $name) {
            $meta = @$flat[$name];
            if (!$meta) continue;

            // Mandatory validate values of array-based, dangerous to hack fields 
            // (e.g. checkboxes, selects, static hidden fields etc.).
            $value = $meta['value'];
            switch ($meta['type']) {
                case 'single':
                case 'multiple':
                    if (!$this->_checkDynamicField(
                        @$meta[$this->MFA_ATTR_DYNAMIC], array_keys($meta['items']),
                        $value, 
                        array($this->MFA_ERRORS['non_existed_value'], $name, $meta['type']),
                        null,
                        $name
                    )) return null;
                    break;
                default:
                    if (isset($meta['original']) || isset($meta[$this->MFA_ATTR_DYNAMIC])) {
                        if (!$this->_checkDynamicField(
                            @$meta[$this->MFA_ATTR_DYNAMIC], trim(@$meta['original']),
                            trim($value), // trim() - for FF hidden field compatibility!!!
                            array($this->MFA_ERRORS['invalid_value'], $name, $meta['type']),
                            null,
                            $name
                        )) return null;
                    }
                    break;
            }

            // Call user-defined validators.
            // Use custom validator if present.
            if (isset($meta[$this->MFA_ATTR_VALIDATOR])) {
                $validators = preg_split('/\s+/s', $meta[$this->MFA_ATTR_VALIDATOR]);
                foreach ($validators as $validatorName) {
                    $noerr = $negate = $modifiers = false;
                    if (!$validatorName) continue;
                    
                    // Process modifiers.
                    if ($validatorName[0] == '@') {
                        // Disable warnings & notices while validator is called.
                        $noerr = true;
                        $validatorName = substr($validatorName, 1);
                    }
                    if ($validatorName[0] == "!") {
                        // Negate validator results.
                        $negate = true;
                        $validatorName = substr($validatorName, 1);
                    }
                    if (preg_match('/^(.*?):(.*)$/s', $validatorName, $p)) {
                        $validatorName = $p[1];
                        $modifiers = $p[2];
                    }
                    
                    // Totally skip manual modifiers in non-manual mode.
                    if ($modifiers == $this->MFA_MODIFIER_MANUAL && $checkAllFields) {
                        continue;
                    }
                    
                    // Validator name MUST always be started with 'validator_' prefix
                    // (security purpose: we must not allow to call ANY plain function
                    // in the program if form is injected).
                    $func = "validator_$validatorName";
                    
                    // Check if we are subclassed. Function-based validators have priority.
                    if (!is_callable($func) && is_callable(array(&$this, $func))) {
                        $func = array(&$this, $func);
                    }
                    // Check for validator existance.
                    if (is_callable($func)) {
                        // Call validator.
                        if ($noerr) {
                            $oldER = error_reporting(E_ALL & ~E_NOTICE);
                        }
                        $status = call_user_func($func, $meta['value'], $meta);
                        if ($noerr) {
                            error_reporting($oldER);
                        }
                        
                        // Fetch custom message (if present).
                        $message = null;
                        if (!is_scalar($status)) {
                            $message = $status;
                            $status = false; // error occured
                        }
                        
                        // If error detected, report it.  
                        if (!$negate && !$status || $negate && $status) {
                            // $meta['name'] and $name (key od meta item) may differ - e.g. for
                            // "multiple" fields ($name = "sel[]", $meta['name'] = "sel"). So we
                            // need to pass fully-qualified name to validationError.
                            $this->validationError($name, $message, $func);
                            $numErrors++;
                            break;
                        } 
                    } else {
                        $this->validationError($name, array($this->MFA_ERRORS['validator_not_registered'], $func));
                        $numErrors++;
                        break;
                    }
                }
            }
        }
        
        return !$numErrors? $action : null;
    }
    
    
    /**
     * Called when validation error occured for some form element.
     * 
     * May be overriden in derived classes to show beautified errors.
     * Also you may simply use $obj->getErrors() to obtain list of all 
     * errors later.
     * 
     * @param string $name       Name of form element (if null - error for overall form).
     * @param mixed  $message    Message information to show (if present).
     * @param mixed  $validator  Validator reporting an error (optional).
     * @return array Generated error frame.
     */
    function validationError($name, $message, $validator=null)
    {
        $metas = $this->metaForm->getFormMeta();
        // Build string-based validator name.
        if (is_array($validator)) {
            $validatorName = (is_object($validator[0])? get_class($validator[0]) : $validator[0]) . '::' . $validator[1];
        } else {
            $validatorName = $validator === null? null : @strval($validator);
        }
        $this->_mfa_errors[] = $errorItem = array(
            'name'      => $name,
            'message'   => $message,
            'validator' => $validatorName === null? null : strtolower($validatorName), // strtolower - for PHP 4/5 compatibility
            'meta'      => $name !== null? @$metas['items'][$name] : null,   
        );
        if ($this->_mfa_errorHandler) {
            call_user_func($this->_mfa_errorHandler, $errorItem);
        }
        return $errorItem;
    }
    
    
    /**
     * Return list of all validation errors occured during validation.
     * 
     * @return array Information about all validation errors.
     */
    function getErrors()
    {
        return $this->_mfa_errors;
    }
    
    
    /**
     * Pre-defined validators. They are always exist for all actions.
     * 
     * Validator prototype:
     * 
     * function validator_NAME($value, $currentElement)
     * 
     * where:
     * - $value is element value to be validated. E.g., for TEXTAREA
     *   it contains entered value; for file INPUT fields it holds 
     *   information about uploaded file.
     * - $currentElement (optional) is reference to validating element
     *   metadata returned by HTML_MetaForm.
     * 
     * Each validator may return:
     * 1. Scalar value: if it is true, validation succeed, else - failed. For each 
     *    failed validations validationError() is called with $message = null and
     *    $validator set to validator name.
     * 2. Array with elements holding information about validation errors. This
     *    array may be, for example, passed to sprintf() call for error text
     *    generation or processed somewhere else.
     * 
     * So, the only method to succeed validation is return scalar true value.
     * All other values are treated as errors. 
     */
    
    
    /**
     * Validator: check for empty value.
     * 
     * @param string $value  Input value to check.
     * @return               True if value is empty (not filled or 0).
     */
    function validator_empty($value)
    {
        return empty($value);
    }
    
    
    /**
     * Validator: check for field fillness.
     *  
     * @param string $value  Input value to check.
     * @return               True if value is empty (not filled).
     */
    function validator_filled($value)
    {
        return is_scalar($value)? !!strlen(trim($value)) : !empty($value);
    }



    /**
     * Internal methods.
     */

    /**
     * Check field value against allowed list.
     * $dynamic is got from meta:dynamic field. If it is specified without
     * value (e.g. <input meta:dynamic>, all values are allowed by default, 
     * else it contains list of allowed values separated by SINGLE spaces.
     * 
     * @return True on success check, false on error. Also calls validationError(). 
     */
    function _checkDynamicField($dynamic, $allowed, $got, $error, $modifier=null, $name = null)
    {
        // If dynamic field is empty, all values are allowed.
        if ($dynamic == $this->metaForm->MF_META_PREFIX . $this->MFA_ATTR_DYNAMIC) {
            return true;
        }
        
        // Prepare list of allowed values.
        if (!is_array($allowed)) {
            $allowed = array($allowed);
        }        
        if ($dynamic !== null) {
            $allowed = array_merge($allowed, explode(' ', $dynamic));
        }
        
        // Use modifier.
        if ($modifier) {
            $allowed = array_map($modifier, $allowed);
        } 
        
        // Prepare list of actual received values.
        if (!is_array($got)) {
            $got = array($got);
        }
        
        // This is needed because of stranges in HTTP protocol: value of hidden fields
        // without \r's is got from POST array with \r's.
        $got = array_map(array(&$this, '_normalizeCrLf'), $got);
        $allowed = array_map(array(&$this, '_normalizeCrLf'), $allowed);
        
        // All values must be in allowed list.
        // array_diff() documentation: two elements are considered 
        // equal if and only if (string) $elem1 === (string) $elem2.
        if (array_diff($got, $allowed)) {
            $exp = count($allowed) > 1? "(" . join('|', $allowed) . ')' : "'{$allowed[0]}'";   
            $got = count($got) > 1? "(" . join(', ', $got) . ')' : "'{$got[0]}'";
            $error = array_merge((array)$error, array($exp, $got));
            $this->validationError($name, $error);
            return false;
        }
        
        return true;
    }
    
    /**
     * Internal function, used to normailze line breaks.
     * 
     * @param string $st String to notmalize.
     * @return string Resulting string with line breaks in same style.
     */
    function _normalizeCrLf($st)
    {
        return str_replace("\r", "", $st);
    }
}
?>