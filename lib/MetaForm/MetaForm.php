<?php
/**
 * HTML_MetaForm: parse HTML POST forms extracting meta-information about all 
 * elements and save this information in hidden field for later usage.
 *
 * Generated meta-information may be used for:
 * - assign vatious attributes to any form element for later processing;
 * - validate entered values (with user various diagnostics);
 * - hack protection (injection of forms to foreign scripts, insertion
 *   of unexpected POST values, injection of non-existed OPTION items etc.);
 * - run-time form elements enumeration.
 * 
 * Hidden field containing meta-information is digitally signet and cannod
 * be fabricate by hacker.
 * 
 * $Id: MetaForm.php 238 2008-03-17 21:07:17Z dk $
 */
require_once dirname(__FILE__).'/SemiParser.php';

class HTML_MetaForm extends HTML_SemiParser
{
    /**
     * Errors generated by library. Error strings are hold in values of this array,
     * keys are internal and must not be used in application. You may use textual 
     * array values as input strings for gettext (for example). 
     */
    var $MF_ERRORS = array(
        // Do not modify values in the future!
        'hidden_field_required' => 'Hidden field "%s" required for POST form!',
        'bad_signature'         => 'Form data signature check failed!',
    );
    
    /**
     * Assign values to resulting meta-info?
     */
    var $MF_USE_VALUES  = true;
    
    /**
     * Store radio & checkbox labels, <option> values in meta snapshot.
     * If false, values are replaced by null (size & speed economy).
     */
    var $MF_STORE_LABELS = true;
    
    /**
     * Name of hidden form field with packed meta-info.
     */
    var $MF_META_ELT    = "HTML_MetaForm";
    
    /**
     * Use session variable to store meta.
     */
    var $MF_USE_SESSION = false;
    
    /**
     * Prefix of meta-attributes.
     */
    var $MF_META_PREFIX = "meta:";
    
    /**
     * REQUEST_URI of current page (used for FORM action checking).
     */
    var $MF_REQUEST_URI = null;
    
    /**
     * POST form data.
     */
    var $MF_POST = null;
    
    /**
     * Suffix for signed hidden element (ignored while paching/unpacking,
     * comment purposes only).
     */
    var $MF_SIGN_SUFFIX = null;
    
    // Private variables.
    var $_mf_meta          = null;
    var $_mf_sign          = null;
    var $_mf_hash          = null;    
    var $_mf_collectLabels = array();
    var $_mf_collectForms  = array();
    var $_mf_collectMetas  = array();
    var $_mf_collectHashes = null;
    var $_mf_errorHandler  = null;
    var $_mf_post          = null;
    var $_mf_lastError     = null;


    /**
     * Constructor.
     * Create new object & check digital signature (if script is called
     * as POST action).
     */
    function HTML_MetaForm($signature)
    {
        $this->HTML_SemiParser();
        $this->_mf_hash = dechex(crc32(microtime() . uniqid("") . getmypid()));
        if (strlen($signature) < 10) {
            trigger_error("HTML_MetaForm constructor: digital signature is shorter than 10 characters. To be secure, you must always specify signature manually and keep it out of stranger eyes.", E_USER_ERROR);
        }
        $this->_mf_sign = 'Format02' . $signature; // . filemtime(__FILE__);
        $this->MF_REQUEST_URI = @$_SERVER['REQUEST_URI'];
        $this->MF_POST = strtoupper(@$_SERVER['REQUEST_METHOD']) == 'POST'? $this->_getFullPostData() : null; 
    }
    
    
    /**
     * Receive and unpack metadata from previously generated form.
     * In case of signature error - return null and set last error 
     * (see getLastError() method for details).
     * 
     * @return array Form metadata: array(..., 'items'=>..., 'tree'=>..., 'value'=>...).
     */
    function getFormMeta()
    { 
        if ($this->_mf_meta === null && is_array($this->MF_POST)) {
            // Solve metadata.
            if (isset($this->MF_POST[$this->MF_META_ELT])) {
                $packed = $this->MF_POST[$this->MF_META_ELT];
                // If session may be used, get data from session.
                if (isset($_SESSION[$this->MF_META_ELT][$packed])) {
                    $packed = $_SESSION[$this->MF_META_ELT][$packed];
                }
                // Unpack data & check digital signature (may cause errors!).
                $meta = $this->_unpackMeta($packed);
                // Make multidimension array from meta (for complex multi-fields).
                $this->_mf_meta = $meta? $this->_decodeFormMeta($meta, $this->MF_POST) : false;
            } else {
                // If method is POST and signature is mandatory...
                $this->_mf_meta = false; // false means 'unpacking error'.
                $this->_mf_lastError = array($this->MF_ERRORS['hidden_field_required'], $this->MF_META_ELT);
                return null;
            }
        }
        
        // False means 'unpacking error'.
        return $this->_mf_meta === false? null : $this->_mf_meta;
    }
    
    
    /**
     * Return last error occured while POST data processing.
     * Errors are listed in $this->MF_ERRORS.
     * 
     * In case of these errors returned metadata is always null.
     * 
     * @return array  Information about error occured or null of there was 
     *                no error detected.
     */
    function getLastError()
    {
        return $this->_mf_lastError;
    }
    
     
    /**
     * Internal callback methods for HTML_SemiParser.
     *
     * Algorythm:
     * 1. Collect all form tags inserting unique temp marks after each of them.
     *    Group tags into 5 classes: single, multiple, text, action.
     * 2. Determine which marks is placed inside which forms. Now we know
     *    what elements are situated in what forms. Remove temp marks.
     * 3. Add hidden tag with meta-info.
     * 4. While POST processing: parse meta-tag (if present) and unpack it.
     */
    
    
    function tag_form($tag)
    {
        // Unfortunately we MUST process ALL forms (including GET),
        // because container handlers are called AFTER tag handlers.
        // While we process container (e.g. SELECT or TEXTAREA) we 
        // cannot know if we are inside GET or POST form. So - GET
        // forms are processed later, after all metainfo collection
        // (see postprocText() below). 

        // Mark the position of form body with unique hash.
        $hash = $this->_getHash('form');
        $tag['_right'] = $hash . @$tag['_right'];
        $this->_mf_collectForms[$hash] = $tag;
        // Add hash-code for FORM action (for later check).
        // If no "action" attribute specified, browsers send current 
        // REQUEST_URI (WITH QUERY_string, but NOT without!).
        $action = isset($tag['action'])? $tag['action'] : $this->MF_REQUEST_URI;
        $action = $this->_getUriByUrl($action); // only REQUEST_URI
        $this->_addItems("form", $tag, array(array(
            'original' => $action,
        )));
        return $tag;
    }


    function container_label($tag)
    {
        // Collect labels in HTML.
        if (isset($tag['for'])) {
            $this->_mf_collectLabels[$tag['for']] = $tag['_text'];
        }
    }

    
    function tag_input($tag)
    {
        if (!isset($tag['name'])) return;
        $type = isset($tag['type'])? strtolower($tag['type']) : 'text';
        $item = array();
        switch ($type) {
            case "checkbox": 
                $type = 'multiple';
                $item['key'] = isset($tag['value'])? $tag['value'] : "on";
                break;
            case "radio":
                $type = 'single';
                $item['key'] = isset($tag['value'])? $tag['value'] : null;
                break;
            case "hidden":
                $type = 'text';
                $item['original'] = isset($tag['value'])? $tag['value'] : null;
                break;
            case "file":
                $type = 'file';
                break;
            case "submit":
            case "button":
            case "image":
                $type = 'action';
                break;
            default:
                $type = 'text';
                break;
        }
        return $this->_addItems($type, $tag, array($item));
    }
    
    
    function container_textarea($tag)
    {
        if (!isset($tag['name'])) return;
        return $this->_addItems('text', $tag, array(array()));
    }    


    function container_button($tag)
    {
        if (!isset($tag['name']) || strtolower(@$tag['type']) !== 'submit') return;
        return $this->_addItems('action', $tag, array(array()));
    }    


    function container_select($tag)
    {
        if (!isset($tag['name'])) return;
        // Parse all options.
        $type = isset($tag['multiple'])? 'multiple' : 'single';
        $parts = preg_split("/<option\s*({$this->sp_reTagIn})>/si", $tag['_text'], -1, PREG_SPLIT_DELIM_CAPTURE);
        $items = array();
        for ($options = array(), $i = 1, $n = count($parts); $i < $n; $i += 2) {
            $opt = array();
            $this->parseAttrib($parts[$i], $opt);
            $text = rtrim(preg_replace('{</?(option|optgroup)[^>]*>.*}si', '', $parts[$i + 1]));
            if (isset($opt['value'])) {
                $value = $opt['value'];
            } else {
                // Option without value: spaces are shrinked (experimented on IE).
                $value = trim($text);
                $value = preg_replace('/\s\s+/', ' ', $value);
                if (strpos($value, '&') !== false) {
                    $value = $this->_unhtmlspecialchars($value);
                }
            }
            $items[] = array(
                'key'   => $value,
                'label' => $this->MF_STORE_LABELS? $text : null, // emulate "label" attribute
            );
        }
        $this->_addItems($type, $tag, $items);
        return $tag;
    }
    

    /**
     * Metas are added to _collectMetas field. They are grouped by meta hash
     * (unique for each addition). E.g. list of metas may have the same hash.
     */
    function _addItems($type, &$tag, $items)
    {
        // Mark position of this tag in HTML by unique hash.
        $hash = $this->_getHash();
        $tag['_right'] = @$tag['_right'] . $hash;
        
        // Extract general metadata (meta:*) from tag attributes.
        $meta = array();
        foreach ($tag as $attrName=>$value) {
            if (strpos($attrName, $this->MF_META_PREFIX) === 0) {
                $meta[substr($attrName, strlen($this->MF_META_PREFIX))] = $value;
                unset($tag[$attrName]);
            }
        }
        
        // Add each item to _collectMetas.
        foreach ($items as $item) {
            // Grouped by unique hash.
            $this->_mf_collectMetas[$hash][] = $item + array(
                'name'     => @$tag['name'],
                'type'     => $type,
                'custom'   => $meta,
                'id'       => isset($tag['id'])? $tag['id'] : null,
            );
        }
        
        return $tag;
    }


    /**
     * Called before tag parsing.
     */
    function preprocText($text)
    {
        $this->_mf_collectLabels = array();
        $this->_mf_collectMetas = array();
        $this->_mf_collectForms = array(); 
    }
    

    /**
     *  void postprocText($text)
     * Meta-info list has the following structure:
     * name => array(
     *   validator => used validator
     *   ...       => other attributes in meta:*
     *   type      => "action" | "text" | "single" | "multiple"
     *   items     => array( 
     *     key => value  // items of checkboxes, radios and selects
     *   )
     * )
     */
    function postprocText($text)
    {
        // Split text by forms.
        $formChunks = preg_split('/('.$this->_mf_hash.'form\d+\|)/s', $text, 0, PREG_SPLIT_DELIM_CAPTURE);
        $text = $formChunks[0];
        // Remove hashes from text outside all the forms.
        $this->_getMetasInText($text);
        // Now process each form separately.
        for ($i=1, $n=count($formChunks); $i<$n; $i+=2) {
            $hash = $formChunks[$i];
            $content = $formChunks[$i+1];
            // This form tag.
            $formTag = $this->_mf_collectForms[$hash];
            // Extract stored hashes for form fields & clean hashes from text.
            $metas = $this->_getMetasInText($content);
//            printr($metas);
            
            // Process only POST forms!
            if (strtoupper(@$formTag['method']) == 'POST') {
                // Generate hidden tag.
                $packed = $this->_packMeta($metas);
                if ($this->MF_USE_SESSION) {
                    // If session is used, store data in session.
                    $contentHash = $this->_getHashcode($packed);
                    $_SESSION[$this->MF_META_ELT][$contentHash] = $packed;
                    $packed = $contentHash;
                }
                // Add suffix (e.g. - current timestamp) to metadata as comment. This 
                // should help debugging: we always know when form metadata was generated 
                // and detect stupid proxy requests when page is cached for weeks. This 
                // date must NOT be included in digital signature!
                if ($this->MF_SIGN_SUFFIX !== null) {
                    $packed .= " " . $this->MF_SIGN_SUFFIX;
                }
                $hidden = array(
                    '_tagName' => 'input',
                    'type'     => 'hidden',
                    'name'     => $this->MF_META_ELT,
                    'value'    => $packed,
                    '_text'    => null,
                );
                $text .= $this->makeTag($hidden);
            }
            
            $text .= $content;
        }
        return $text;
    }
    

    /**
     * Return all metas situated in text $content.
     * Lookup is performed by meta hashes. 
     * All hashes are cleared from the text on method finish.
     */ 
    function _getMetasInText(&$content)
    {
        // Extract stored hashes for form fields.
        $this->_mf_collectHashes = array();
        $content = preg_replace_callback('/('.$this->_mf_hash.'\d+\|)/', array(&$this, '_extractHashCallback'), $content);
        
        // Collect all metas of the current form.
        $formMeta = null;
        $eltMetas = array();
        foreach ($this->_mf_collectHashes as $hash) {
            if (!@is_array($this->_mf_collectMetas[$hash])) continue;
            foreach ($this->_mf_collectMetas[$hash] as $eltMeta) {
                if ($eltMeta['type'] == 'form') {
                    $formMeta = $eltMeta;
                } else {
                    $eltMetas[] = $eltMeta;
                }
            }
        }
        if (!$formMeta) {
            // In case we have no FORM meta - just do nothing, called for FORMless text.
            return;
        }
        
        // Group single/multiple elements.        
        $metasByName = array();
        foreach ($eltMetas as $eltMeta) {
            // Source: $eltMeta (const).
            // Destination: $meta (created from scratch).
            $name = $eltMeta['name'];
            
            // Prepare target meta.
            $meta =& $metasByName[$name]; // create new or get existed ALIAS!
            if (!$meta) {
                $meta = $eltMeta['custom'];
            } else {
                $meta = $eltMeta['custom'] + $meta;
            }
            
            // Fetch label text from LABEL container if we have no explicit "label".
            if (!isset($eltMeta['label']) && isset($eltMeta['id']) && isset($this->_mf_collectLabels[$eltMeta['id']])) {
                $eltMeta['label'] = $this->_mf_collectLabels[$eltMeta['id']];
            }
            
            $meta['type'] = $eltMeta['type'];
            if (isset($eltMeta['id'])) $meta['id'] = $eltMeta['id'];
            if (isset($eltMeta['original'])) {
                $meta['original'] = $eltMeta['original'];
            }

            // Collect items for multi-metas.
            if ($meta['type'] == "multiple") {
                // Multiple meta may be flag or set of flags (trailed with "[]").
                // "Multiple" items (multiselects and groups of checkboxes) must have 
                // "[]" at the end of name. If not, they are single.
                if (substr($name, -2) == '[]') {
                    $name = substr($name, 0, -2); // remove trailing []'s
                    $meta['items'][$eltMeta['key']] = @$eltMeta['label'];
                    // Label may absent in <input type="checkbox" name="c[]">. 
                } else {
                    // Flag-based checkbox. Force 0 or non-zero.
                    $meta['type'] = "flag";
                    $meta['key'] = isset($eltMeta['value'])? $eltMeta['value'] : null;
                }
            } else if ($meta['type'] == "single") {
                // Single meta (SELECT or set of options), may not contain label attribute.
                $meta['items'][$eltMeta['key']] = @$eltMeta['label'];
            }

            // Save meta name.
            $meta['name'] = $name;
                        
            if (isset($meta['items'])) {
                // Find label by ID on first item of single/multiple group.
                // In such group all elements contain same ID of group container (e.g. SELECT).
                if (count($meta['items']) == 1 && isset($eltMeta['id']) && isset($this->_mf_collectLabels[$eltMeta['id']])) {
                    $meta['label'] = $this->_mf_collectLabels[$eltMeta['id']];
                }
            } else {
                // All other metas (non-single and non-multiple).
                if (isset($eltMeta['label'])) {
                    // We have FormPersister pseudo-attribute "label".
                    $meta['label'] = $eltMeta['label'];
                    // Remove trailing "^" from label name if present (FormPersister legacy). 
                    if (substr($meta['label'], -1) == '^') {
                        $meta['label'] = substr($meta['label'], 0, -1);
                    }
                }
            }                        
        }
        
        // All element metas are items of the FORM.
        $formMeta['items'] = $metasByName;
        
        // Merge custom fields with basics.
        $custom = $formMeta['custom'];
        unset($formMeta['custom']);
        $formMeta = $custom + $formMeta;
        
        return $formMeta;
    }


    /**
     * Remove hash from the string and add it to buffer.
     */
    function _extractHashCallback($m)
    {
        $this->_mf_collectHashes[] = $m[1];
        return '';
    }
    
    
    /**
     * Return unique hash value. Format: <GlobalHash><type><id>|
     * Field <type> may be empty (e.g. - for form fields).
     */ 
    function _getHash($type='')
    {
        static $uniq = 0;
        $uniq++;
        return $this->_mf_hash . $type . $uniq . "|";
    }


    /**
     * Pack the meta (any array) into single string with minimal length.
     */
    function _packMeta($meta)
    {
        $s = serialize($meta);
        if (is_callable($f='gzcompress')) $s = 'z' . $f($s);
        $s = base64_encode($s);
        $s = $this->_sign($s);
        return $s;
    }


    /**
     * Unpack the meta from string.
     */
    function _unpackMeta($s)
    {
        // First remove comments (started with space) from the end of metadata.
        // They may contain any debug information (e.g. - form generation date).
        $s = preg_replace('/\s.*/s', '', $s);
        // Unsign the string.
        $s = $this->_unsign($s);
        if ($s === null) {
            $this->_mf_lastError = array($this->MF_ERRORS['bad_signature']);
            return null;
        }
        // Note: we may be always sure that $s is fully valid here.
        // So - no @ needed in the future.
        $s = base64_decode($s);
        if (substr($s, 0, 1) == 'z') {
            if (is_callable($f='gzuncompress')) {
                $s = $f(substr($s, 1));
            } else {
                $this->_mf_lastError = array($this->MF_ERRORS['bad_signature']);
                return null;
            }
        }
        $meta = unserialize($s);
        return $meta;
    }

    /**
     * Hash function for digital sidning.
     */
    function _getHashcode($s)
    {
        return md5($s);
    }


    /**
     * Digitally sign the string.
     */
    function _sign($s)
    {
        $sign = $this->_getHashcode($s . $this->_mf_sign);
        return "$sign-$s";
    }


    /**
     * Digitally unsign the string. Return null on error.
     */
    function _unsign($signed)
    {
        @list ($sign, $s) = explode('-', $signed, 2);
        if (!isset($s)) return null;
        if (strcmp($this->_getHashcode($s . $this->_mf_sign), strval($sign))) return null;
        return $s;
    }

    
    /**
     * Convert plain metadata to multidimension array (as in $_GET and $_POST).
     * Used for forms with complex field names: a[b][c][] etc.
     * Called usually ONLY on POST form processing, not each time page loaded.
     * Also check if field values are consistent with metadata (e.g. hidden 
     * field is unchanged manually and "select" value is present in <option>'s).
     * Each resulting elements will have the following structure:
     * elementName => array(
     *   'type'      => text | action | single | multiple,
     *   'label'     => corresponding <label>...</label> content
     *   'value'     => entered value (if MF_USE_VALUES is true)
     *   'name'      => full name of form element (e.g. field[key1][key2])
     *   'original'  => original value of the element (for hidden fields and forms)
     *   'items'     => array(items of selects, checkboxes etc.)
     * );
     */
    function _decodeFormMeta($metas, $valuesArray)
    {
        require_once dirname(__FILE__).'/SemiParser.php';

        // Second pass: make meta tree.
        $flatMetas = $metas['items'];
        $treeMetas = $autoindexes = $values = array();
        foreach ($flatMetas as $k => $meta) {
            // Get name structure.
            $name = $meta['name'];
            $nameParts = HTML_FormPersister::_splitMultiArray($name); // may be modified later!
            
            // Set values.
            if ($this->MF_USE_VALUES) {
                $value = null;
                
                // Fetch the value.
                if ($meta['type'] == "action" && count($nameParts) == 1) {
                    // This is possibly <input type="image" name="aaa"> field. E.g., 
                    // $_GET contains "aaa_x" and "aaa_y" fieds.
                    if (is_numeric($x = @$valuesArray["{$name}_x"]) && is_numeric($y = @$valuesArray["{$name}_y"])) {
                        $value = array($x, $y);
                    }
                } 
                
                if ($value === null) {
                    // This is not "image" field, or "image" with [] parts 
                    // (PHP always ignores .x and .y after [] part, so - remain only "y" coord).
                    if (($v = HTML_FormPersister::_deepFetch($valuesArray, $nameParts, $autoindexes)) !== false) {
                        $value = $v;
                    }
                }

                // For multi-selects value is ALWAYS array.
                if ($value === null && $meta['type'] == "multiple") {
                    $value = array();
                }

                // Single select with size>1 and set of radio-buttons without
                // checked item ALSO could generate NULL in value. But we must
                // process such cases via meta:dynamic attribute.   

                // Flag-based checkbox may need correction.
                if ($meta['type'] == 'flag') {
                    if ($meta['key'] === null) {
                        // If checkbox has no 'value' attribute - completely 
                        // boolean element (browser sends "on").                        
                        $value = intval(!!$value);
                    }
                    unset($meta['key']);
                }
                
                // Make values array ("trusted $_POST").
                $curValue =& $values;
                foreach ($nameParts as $part) {
                    $curValue =& $curValue[$part];
                }
                $curValue = $value;
                
                // Save new value back to meta.
                $meta['value'] = $value;
            }
            
            // Make deep (tree-like) array.                
            $curTree =& $treeMetas;
            foreach ($nameParts as $part) {
                if (!strlen($part)) break;
                $curTree =& $curTree[$part];
            }
            $curTree = $meta;
            
            // Save modified meta back to array. 
            $flatMetas[$k] = $meta;
        }
        
        // Create resulting metadata.
        $metas['items'] = $flatMetas;
        $metas['tree'] = $treeMetas;
        if ($this->MF_USE_VALUES) {
            $metas['value'] = $values;
        }
        
        // Return full meta-information.
        return $metas;
    }

    
    /**
     * Return URI part of full URL.
     */
    function _getUriByUrl($url)
    {
        $uri = preg_replace('{^\w+://[^/]+}s', '', $url);
        $uri = preg_replace('{#.*}s', '', $uri);
        if (substr($uri, 0, 1) === '?') {
            // URL started with '?'. Prepend current script name.
            $sn = preg_replace('/\?.*/s', '', $this->MF_REQUEST_URI);
            $uri = $sn . $uri;
        }
        return $uri;
    }
    
    
    /**
     * Return $_POST with attached $_FILES on corresponding places.
     * The problem is that data in $_FILES is in stupid format; we need to 
     * convert it before work. 
     */
    function _getFullPostData()
    {
        $data = $_POST;
        if (@$_FILES) {
            foreach ($_FILES as $firstKey => $container) {
                foreach ($container as $field => $values) {
                    $this->__transformFilesValueArr($field, $values, $data[$firstKey]);
                }
            }
        }
        return $data;
    }
    
    
    /**
     * Assistant recurrent function for $_FILES transforming.
     */
    function __transformFilesValueArr($field, $hashSrc, &$hashDst)
    {
        if (!is_array($hashSrc)) {
            $hashDst[$field] = $hashSrc;
            return; 
        }
        foreach ($hashSrc as $k => $v) {
            $this->__transformFilesValueArr($field, $v, $hashDst[$k]); 
        }
    }
}
?>