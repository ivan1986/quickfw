Тут планируется написание документации по фреймворку
Также сокральные мысли по тому, как тут что переделать, прикрутить и прочее

Блин, отвалились сессии в случае не релиза :(
нужно курить доку по сессиям - перехватчик не пашет, и вообще что-то не стартуют

Ы, вроде починили, но курить еще нуно :)

пара мыслей
1) сделать функцию хедер для выноса css и js вверх, в основной шаблон модуля
	get реализует $a[name].=значение
	out реализует echo $a[name]
	{outHead name='name'}
	
	{getHead name='name'}
	
	{/getHead}
	
	Реализовал единственную загрузку блока
	Обработка фильтров происходит только при displayMain, так как в массиве нужно делать unset
	теперь логика работы такая:
	при захвате значение заменяется, но если указать параметр join, то тогда склеивается
	outHead для данного имени не обязательный, если он есть, то выводится на его месте,
	если нет, то тогда в начале файла - после </head>
	
	добавил addJS и addCSS
	
	При кешировании нужно вместе с модулем кешировать результаты всех вызовов head из него 
	Сейчас если значение модуля берется из кеша - head остается пустым
	
	Нуно курить с кешем и смарти
	
2) ./library/QuickFW/Module обозвать компонентами
разнести по модулям в application, сделать вызов как у роутинга (по умолчанию если модуль не указан, то текущий а не def)
Хм, не нужно разделять модули и контролеры
сделано

3) мысля по разбиению на папки - заменять в урле символ типа - или _ на / тем самым делая разбитие контроллеров по директориям
сделано

4) для функции добавить переменную кеш, для сайта сделать настройку дефолтное состояние переменной тем самым можно указывать, кешировать состояние или нет для каждого модуля, есть проблема - как проверять установлена переменная или нет до запуска, так как лезть каждый раз для некешируемой страницы в кеш - фигня.

5) мысля по поводу сохранения кеширования - массив закешированных шаблонов (их id) класть в кеш, при старте извлекать, и если что не запускать

6) вообще по хорошему нужно разделить шаблоны по модулям, модуль нельзя просто кинуть в папку app и чтобы он заработал, а совпадение шаблонов двух разных модулей красиво решается с помошью жестких или символически ссылок, помоему это лучше, чем лишать возможности и забивать шаблоны вместе
сделано

7) мысль по поводу вызова файлов без роутера - если не хочет человек юзать контроллеры, то можно сделать такое - если файл найден, то вызываем инициализацию (подрубление базы, настройка основных фич, кстати а может сделать два вида вызова существующих файлов - в виде plainPHP или если это сразу шаблон смарти), а затем меняем директорию и вызываем файл.
Или это я изврасранец?

8) нужно сделать процедуру определения - где я и какая страница сейчас генерится - возврат MCA
сделано
в роутере есть три переменных - текущий uri, текущий модуль, родительский модуль

Про кеширование аццки распихано по TO DO

Валера надоумил:
1) роутинг
baseurl, (+ функции в смарти - baseurl и siteurl)	
-- я это в каком-то проекте делал, кажись для лавпланета, для этого и нужен был хост в конфиге

index file - для работы без htaccess (по умолчанию пустой)
-- а index.php чем не кошерен? или я что-то не понимаю

def ext - для СЕОнистов (кто это такие - к Валере ;) (нифига. К Диме Смирнову ;-)
все урл в генерируемом документе выглядят к base_url/index.php/$1.defext
-- а нафига? некрасиво же

1) это все для того чтобы - если у нас проект в папке, отличной от wwwroot
2) если у нас на хостинге запрещен .htaccess
3) Это опять к Валере - он утверждает что есть заказчики, которым нужно обязательно .html в конце, иначе не кошерно

2) бекроутинг - генерация урла по контроллеру и экшену
1 и 2 - Общеей функцией
-- можно, хотя зачем - не знаю :)

Сделал заготовку для роутинга и бекроутинга

3) адреса как в кодеигнайтере как второй способ (имхо способ хороший, Дрюн, твое мнение?)
module/control/action/p1/p2/p3/p4 - значения
actionAction($p1,$p2,$p3,$p4) - имена
-- можно, шо так кол юзверь фанк, что так кол юзверь фанк, единственная херня,
-- что если мы вдруг захотели другой контроллер из своего вызвать, может быть неудобно
почему, может быть вообще два варианта вызова
module:module/control/action/p1/p2/p3/p4
module:module.control.action(p1,p2,p3,p4)

сделано


при вызове модулей и экшенов по совпадающим урлам не происходит вызова одной и той-же функции
при вызове из URL module/control/show вызывается ShowAction
при вызове из модуля - ShowModule
при совпадении действий предпочтительно вызывать другую функцию возможно с параметрами

function ShowAction($news=10)
{
...
}

function ShowModule()
{
	return $this->ShowAction(5);
}

Поддержка русских урлов, два режима передачи параметров

Нашел на phpfaq.ru
if (isset($_REQUEST[session_name()])) session_start();
возможно имеет смысл добавить и сделать в классе сессий функцию start
сделано

Обьединил авторизацию и сесии, теперь сесии стартуют только на страницах с авторизаций
Изменена логика авторизации - контроллер наследуется от класса QuickFW_Auth
перекрывая функцию проверки, если нужно и при вызове конструктора осуществляется либо редирект на логин либо другая проверка
Также нужно немного причесать этот класс...

http://www.dklab.ru/chicken/nablas/48.html - пофтыкать, прикрутить сквозное кеширование...
Пофтыкал, прикрутил

Добавлен глобальный массив globalData

ВНИМАНИЕ! фреймворк перенесен 
при обновлении и использовании авторизации 
require_once(LIBPATH.'/QuickFW/Auth.php');
нужно заменить на 
require_once(QFWPATH.'/QuickFW/Auth.php');

ВНИМАНИЕ! Изменение во временных файлах
если используется смарти, то для каждого модуля нужно создать в папке tmp/templates_c папку с его именем
Это сделано из-за компиляции шаблонов смарти

Поменял конфиг на php
Прогнал профайлером
результаты не очень :(
Михалыч был прав - смарти зло, еще как выяснилось - симпла тоже зло, но меньшее :)
Вообще сильно тупит на инклудах библиотек - парсинг файлов смарти отнимает половину времени, если не выводится шаблон
При выводе шаблона смарти занимает >95 процентов времени, если не выводится было >50

пофиксил - теперь 404 отдается 150 раз в секунду
index с компонентами, функциями, и всем без коннекта к базе - 40
с коннектом к базе - 30, и это без прикрученного к базе кеширования :)

При использовании PlainView - без коннекта к базе - 120 страниц в секунду
С коннектом - 62

Правда <?php echo 1; ?> отдается 1200-1500 раз в секунду :(

Вырезал немного хлама из симплы, на pconnect не переводил.

Прикрутил различные шаблонизаторы, нужно допиливать PlainView
Вопрос в том, как сделать вызов из PlainView модуля, наверное нужно еще один способ передачи...

ОПИСАНИЕ ЧИТАТЬ ОТСЮДА: (вверху были наши мысли, переживания, чувства, детские комплексы, привычки нехорошие и все такое)

Описание:

В общем и целом:
Этот фреймворк представляет собой обьединение небольших библиотек и добавление того, чего им не хватает для создания крупных сайтов

Для отделения представления страницы от логики хорошо подходит smarty, можно было бы конечно написать свой шаблонизатор, но смарти хороший шаблонизатор, известный и часто используемый, а недостатков в нем довольно мало, причем некоторые исправляются этим фреймворком.
Главный недостаток smarty - скорость работы, хотя конечно ее хватает для ненагруженных приложений, но если нагрузка критична, то есть смысл использовать PlainPHP - чистый PHP код, но в этом случае вам будет проще смешать логику приложения с оформлением, чего желательно избегать.

Для работы с базой данных тоже нужно что-то :)
Была выбрана библиотека DbSimple которая известна посетителям сайта www.dklab.ru

Кеширование еще не прикрученно :(

Остается написать взаимодействие этих компонентов и разгребание url ака роутер и контроллеры :)
идея контроллеров взята с Зенда, но в отличае от него здесь отсутствует много не нужного.


Распишем структуру фреймворка и предлогаемые способы написания сайтов

Начнем со структуры папок
./tmp - название говорит само за себя - сюда будет складываться все, что нужно для работы
        - скомпиленные шаблоны смарти
        - кеш, если файловый
        - еще что-нить

./www - DocumentRoot - сюда будет класться статика и код, если не используются контроллеры
./application - здесь находятся модули, контроллеры и шаблоны.
в этих двух папках вы пишете свой сайт :)

./QFW - здесь находится весь фреймворк

./lib - здесь находятся библиотеки, которые могут понадобиться для сайта
сюда предпочтительно добавлять стороннии библиотеки
и использовать их например так:
require_once(LIBPATH.'/Name.php');
QFW::$libs['name']->func();
для инициализации добавив 
QFW::$libs['name'] = new Name();

В папке ./application/ находятся папки модулей сайта в которых можно размещать.
Выбор контроллера для выполнения запроса происходит на основе адреса:
сначало проверяется наличие файла в /www - если там есть этот файл, то либо это статика, либо вы отказались использовать роутер, и это php файл, на него отдается управление и он выполняется (если он php)

В папке ./blankApp/ находится пустое приложение, которое выдает только страничку "It's Work!!!"
В папке ./ClassTemplates/ Шаблоны классов шаблонизатора и кешера, чтобы можно было написать обертку для нужного.

Интересности начинаются когда файл в /www отсутствует
тогда URI разбивается по компонентам и пристально изучается :)

сначало из адреса выделяется модуль сайта - это первый компонент адреса и проверяется, существует ли папка этого модуля, если папка существует, то считается, что используется модуль по умолчанию - default, модули удобно использовать когда есть несколько почти не зависимых частей сайта, например сам сайт и админка, модулей по идее должно быть не много, небольшие сайты обходятся одним или двумя

в папке модуля папка controllers - оттуда и вызываются контроллеры, которые определяются вторым компонентом адреса (хотя чаще первым, так как восносном используется контроллер default). Контроллер должен присутствовать, запрос /news/ выдаст ошибку если отсутствует файл /default/controllers/NewsController.php или /news/controllers/IndexController.php - контроллер Index подставляется по умолчанию, если адрес / или /[module]/

Следующий параметр определяет действие в классе контроллера, которое будет вызвано - по умолчанию indexAction все такие функции заканчиваются на Action
Для модулей будет вызвана функция, оканчивающаяся на 'Module', также вызвав $router->route($url,$type); можно указать тип функции, которая будет вызвана, например для вызова действия из консоли по крону или какой-то программой по событию

далее следуют параметры - есть два варианта передачи параметров - по имени и по позиции
при передачи по позиции вызов
module/control/action/p1/p2/p3/p4 
преобразуется в вызов функции
actionAction($p1,$p2,$p3,$p4) из контроллера control

при передаче параметров по имени первый параметр пустой - в адресе идут подрят два слеша
вызов
module/control/action//p1/z1/p2/z2/... 
преобразуется в вызов функции
actionAction() из контроллера control
с передачей ей первым параметром массива {p1=>z1,p2=>z2,...}
также параметры добавляются в массивы _GET и _REQUEST
и в случае нечетного количества оставщихся - значение последнего - пустая строка

при вызове функций и передаче параметров поддерживаются русские URL,
в частности по русски могут называться модули контроллеры и экшены

Идея контроллеров была взята из ZendFramework, но от MVC остался только контроллер :)

Для смарти был написан ресурс module - это компонент - как-бы маленькая страничка встроенная в другую.
для его пдключения в смарти пишется что-то похожее на 
{include file="module:module/control/action/p1/p2/p3"}
при этом управление передается функции actionModule из контроллера и модуля - правила формирования как в url
эта функция генерирует часть страницы так-же как и обычную страницу и результат вставляется в указанное место.

Такие инклуды удобны для активных блоков, например новостей, форм авторизации, пейдженаторов, погоды, сложного меню и прочего.
При вызове в двойных кавычках подставляются значения переменных, и тем самым можно передавать параметры.
Допускается произвольная вложенность и помещение их в любые шаблоны.

Пока при использовании модулей в компоненте должна присутствовать функция getTimestamp($action,$params) которая возвращает время, на которое можно закешировать обьект.
После того как будет приделан кешер функция обретет смысл :) Сейчас она влияет только на Smarty.

Для работы с сессиями существует класс авторизации, который также стартует сесии и поддерживает регистрацию пользователя с сохранением его положения на сайте, что упрощает использование сайта в случае потери сессий или при необязательной регистрации.
Для использования сессий или авторизации нужно прямо или косвенно наследовать контроллер от класса QuickFW_Auth
и переопределить конструктор и метод проверки пользователя.

В случае, если конструктор вызывает только $this->session() стартуют простые сессии
если же вызывается конструктор класса QuickFW_Auth, то сессии стартуют только после логина и логин может происходить в любом месте сайта.

Конструктор QuickFW_Auth принимает два параметра и возвращает true|false
Первый параметр - имя авторизации - соответствует элементу массива $_SESSION ($this->userdata ссылка на $_SESSION[$name])
Второй параметр - редирект в случае неудачной попытки авторизации - по умолчанию отсутствует

Сессия стартует автоматически при isset($_REQUEST[session_name()])
если сессия не стартовала, то вызывается функция checkUser, которую можно переопределить в производном классе и которая должна вернуть данные о пользователе - они будут записаны в $this->userdata или false в случае если логин не произошел
не путайте не произошедший логин и неудачный логин - логин может произойти при любом запросе, но происходит довольно редко, поэтому функция checkUser должна вначале проверять попытку логина - в простейшем случае
if (!isset($_POST['login']))
	return false;
в самом начале функции
также помните о том что в случае авторизации через форму страница будет сгенерирована POST запросом, для этого существует ключ redirect в возвращаемом массиве (очевидно вы будете использовать его в качестве хранилища данных о пользователе) который указывает перенаправить ли куда-нибуть после логина - если он ===true, то перенаправление происходит на текущую страницу, иначе выполняется $router->redirect($_SESSION[$this->name]['redirect']); ключ в массиве не сохраняется, если же ключ не установлен, то никаких перенаправлений не происходит.

Также есть файл application/rewrite.php - здесь можно прописать прямые и обратные преобразования URI с помошью регулярных выражений, они применяются все последовательно.

В коде используются три глобальных обьекта - $router, $view и $db - обьекты для роутинга, шаблонизатора и DbSimple - подключение к базе происходит только при необходимости, также есть встроенное кеширование (местами, частично прикрученное :).
$router, $view и $db, а также $globalData и	$libs доступны как статические члены класса QFW (например QFW::$view)

Также для смарти написаны функции addCSS, addJS, getHead/outHead
addCSS и addJS добавляют подключение к страницам файлов JS и CSS, при этом они следят за уникальностью файлов
getHead/outHead захватывают контент и потом выводят его в указанное место

Настройка фреймворка:
в файле application/default.php указаны параметры модулей
также можно создать файл с именем $_SERVER['HTTP_HOST'] и расширением php для специфической конфигурации произвольного хоста



Пример простейшего контроллера, шаблона и основного шаблона (PlainPHP):

default/templates/main.html:
<html>
<head><title><?=$title?></title></head>
<body>
<?=$content ?>
</body>
</html>

default/templates/index.html:
Страничка сайта
Превед, <?=$user ?>!

default/controllers/IndexController.php:
class IndexController
{
	public function indexAction()
	{
		QFW::$view->assign('user','медвед');
		QFW::$view->assign('title','заголовок');
		return QFW::$view->fetch('index.html');
	}
	
}

Полученный результат:
<html>
<head><title>заголовок</title></head>
<body>
Страничка сайта
Превед, медвед!
</body>
</html>
