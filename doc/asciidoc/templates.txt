[[Templater]]
Шаблонизаторы
-------------

[NOTE]
В этом разделе пойдет речь восновном о PlainPHP, другие будут очень притянуты за уши :)

Движок поддерживает работу с несколькими шаблонизаторами.

Шаблонизатор настраивается в +$config[\'templater']+ и имеет два обязательных параметра.

[source, php]
---------------------------------------------
$config['templater'] = array(
	'name'      => 'Имя',
	'def_tpl'   => 'Основной шаблон',
);
---------------------------------------------

Каждый класс шаблонизатора наследуется от общего предка, обеспечивающего стандартный интерфейс и реализацию типовых дествий.

[source, php]
---------------------------------------------
include::../../QFW/Templater/Templater.php[]
---------------------------------------------

Основные функции это +assign+ и +fetch+, причем вторую обязательно нужно переопредетить - она возвращает обработанный шаблон.

На данный момент есть обертки для шаблонизаторов *Smarty* и *Twig* Проксирующий шаблонизатор и PlainPHP.

Smarty, Twig и остальные
~~~~~~~~~~~~~~~~~~~~~~~~

Если вы хотите использовать какой-то свой шаблонизатор, то для него нужно написать адаптер, наследуемый от класса +Templater+.
Для Smarty и Twig уже написаны эти адаптеры - они требуют наличие шаблонизаторов в папках +lib/{Smarty,Twig}+ соответственно.

Проксирующий шаблонизатор
~~~~~~~~~~~~~~~~~~~~~~~~~

Шаблонизатор +Proxy+ позволяет использовать несколько различных шаблонизаторов в одном проекте, что может быть 
полезно в случае смены шаблонизатора или если в каком-то шаблонизаторе есть "Фишка", но в целом его неудобно использовать :)

[source, php]
---------------------------------------------
$config['templater']= array(
	'name'      => 'Proxy',
	'def_tpl'   => 'main.html',
	'exts' => array(
		'tpl' => 'Smarty',
		'html' => 'PlainView',
	),
);
---------------------------------------------

Дополнительный параметр +exts+ это массив соответствий расширений и шаблонизаторов. Тем самым расширение указывает какой шаблонизатор вызвать при обработке шаблона.

[[PlainPHP]]
PlainPHP
~~~~~~~~

Этот шаблонизатор представляет собой обычное подключение PHP файла и возвращение результата через перехват буфера вывода.
Перед подключением файла в область видимости файла вынимаются все переменные, установленые функцией +assign+, дополнительные функции доступны через +$this+ и доступ к плагинам через +$P+. 

помомо стандартных функций PHP доступны следующие функции:

esc::
	Экранировка - сокращение от htmlspecialchars, настроенная на utf-8

block()::
	Вызов <<block,блока>>

[NOTE]
Написать все это по русски

Применение функции к блоку
^^^^^^^^^^^^^^^^^^^^^^^^^^

Захват блока и применение к нему произвольной функции

.Пример захвата блока
=====================================================================
[source, php]
---------------------------------------------------------------------
<?php $this->begin()->strtoupper(); ?>
zzzzzzzzzzzzzzzzzzz
<?php $this->end(); ?>
---------------------------------------------------------------------
Результат:

  ZZZZZZZZZZZZZZZZZZZ
=====================================================================

.Пример захвата блока и передачи объекту
=====================================================================
[source, php]
---------------------------------------------------------------------
<?php $this->begin(Helper::get())->covert(2); ?>xxx<?php $this->end(); ?>
---------------------------------------------------------------------
[source, php]
---------------------------------------------------------------------
class Helper
{
	public function get() {return new self();}
	
	public function covert($text, $int)
	{
		return $text.$int;
	}
}
---------------------------------------------------------------------

Результат:

  xxx2
=====================================================================

Наследование шаблонов
^^^^^^^^^^^^^^^^^^^^^

Довольно большой недостаток написания шаблонов на простом PHP это отсутствие возможности наследовать шаблоны, 
поэтому для облегчения были напимсаны функции +extend+ и +bl+ - это сокращения для вызова захвата блока с
вызовом функций, поэтому блок так-же нужно завершать вызовом +$this->end()+

В главном шаблоне указываются блоки, которые могут быть заменены в наследуемых, а наследуемые указывают 
от какого шаблона наследуется эта часть и новые значения блоков.

.Пример наследование
=====================================================================
Главный шаблон - parent.html
[source, php]
---------------------------------------------------------------------
parent text 1
<?php $this->bl('ttt') ?>
parent block ttt
<?php $this->end() ?>
parent text 2
<?php $this->bl('zzz') ?>
parent block zzz
<?php $this->end() ?>
---------------------------------------------------------------------
Наследуемый шаблон child.html
[source, php]
---------------------------------------------------------------------
<?php $this->extend('parent.html') ?>
<?php $this->bl('ttt') ?>
child block ttt
<?php $this->end() ?>
child text 1
<?php $this->end() ?>
child text 2
---------------------------------------------------------------------
Результат (при использовани parent.html):
---------------------------------------------------------------------
parent text 1
parent block ttt
parent text 2
parent block zzz
---------------------------------------------------------------------
Результат (при использовани child.html):
---------------------------------------------------------------------
parent text 1
child block ttt
parent text 2
parent block zzz
child text 2
---------------------------------------------------------------------
=====================================================================

Т.о. в наследуемых шаблонах можно переопределять блоки, а то, что находится в extend но не в bl игнорируется. Кроме того можно добавлять текст и новые блоки до и после шаблона,

Наследование по сути является вставкой в указанное место "родительского" шаблона с заменой указанных блоков.
