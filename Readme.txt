Тут планируется написание документации по фреймворку
Также сокральные мысли по тому, как тут что переделать, прикрутить и прочее

Блин, отвалились сессии в случае не релиза :(
нужно курить доку по сессиям - перехватчик не пашет, и вообще что-то не стартуют

пара мыслей
1) сделать функцию хедер для выноса css и js вверх, в основной шаблон модуля
	get реализует $a[name].=значение
	out реализует echo $a[name]
	Написано, с помошью outputfilter smarty
	{outHead name='name'}
	
	{getHead name='name'}
	
	{/getHead}
	
	Хм, нужно реализовывать единственную загрузку блока, иначе смысла нету...
	
	добавил addJS и addCSS
	
	
2) ./library/QuickFW/Module обозвать компонентами
разнести по модулям в application, сделать вызов как у роутинга (по умолчанию если модуль не указан, то текущий а не def)
Хм, не нужно разделять модули и контролеры
сделано

3) добавить основной шаблон на каждый модуль, вывод сделать перехватом потока, и модуля и контроллера (?)
неа, нафиг

4) мысля по разбиению на папки - заменять в урле символ типа - или _ на / тем самым делая разбитие контроллеров по директориям
5) для функции добавить переменную кеш, для сайта сделать настройку дефолтное состояние переменной тем самым можно указывать, кешировать состояние или нет для каждого модуля, есть проблема - как проверять установлена переменная или нет до запуска, так как лезьть каждый раз для некешируемой страницы в кеш - фигня.
6) мысля по поводу сохранения кеширования - массив закешированных шаблонов (их id) класть в кеш, при старте извлекать, и если что не запускать
7) вообще по хорошему нужно разделить шаблоны по модулям, модуль нельзя просто кинуть в папку app и чтобы он заработал, а совпадение шаблонов двух разных модулей красиво решается с помошью жестких или символически ссылок, помоему это лучше, чем лишать возможности и забивать шаблоны вместе
сделано

8) переработать автолоад - он вообще по идее должен будет подключать классы приложения из текущего модуля (?)
Теперь автолоад не используется для классов фреймворка

9) мысль по поводу вызова файлов без роутера - если не хочет человек юзать контроллеры, то можно сделать такое - если файл найден, то вызываем инициализацию (подрубление базы, настройка основных фич, кстати а может сделать два вида вызова существующих файлов - в виде plainPHP или если это сразу шаблон смарти), а затем меняем директорию и вызываем файл.
Или это я изврасранец?

Про кеширование аццки распихано по TO DO

Валера надоумил:
1) роутинг
baseurl, (+ функции в смарти - baseurl и siteurl)	
-- я это в каком-то проекте делал, кажись для лавпланета, для этого и нужен был хост в конфиге

index file - для работы без htaccess (по умолчанию пустой)
-- а index.php чем не кошерен? или я что-то не понимаю

def ext - для сионистов (кто это такие - к Валере ;)
все урл в гнерируемом документе выглядят к base_url/index.php/$1.defext
-- а нафига? некрасиво же

1) это все для того чтобы - если у нас проект в папке, отличной от wwwroot
2) если у нас на хостинге запрещен .htaccess
3) Это опять к Валере - он утверждает что есть заказчики, которым нужно обязательно .html в конце, иначе не кошерно

2) бекроутинг - генерация урла по контроллеру и экшену
1 и 2 - Общеей функцией
-- можно, хотя зачем - не знаю :)

Сделал заготовку для роутинга и бекроутинга

3) адреса как в кодеигнайтере как второй способ (имхо способ хороший, Дрюн, твое мнение?)
module/control/action/p1/p2/p3/p4 - значения
actionAction($p1,$p2,$p3,$p4) - имена
-- можно, шо так кол юзверь фанк, что так кол юзверь фанк, единственная херня,
-- что если мы вдруг захотели другой контроллер из своего вызвать, может быть неудобно
почему, может быть вообще два варианта вызова
module:module/control/action/p1/p2/p3/p4
module:module.control.action(p1,p2,p3,p4)

сделано

Поддержка русских урлов, два режима передачи параметров

Нашел на phpfaq.ru
if (isset($_REQUEST[session_name()])) session_start();
возможно имеет смысл добавить и сделать в классе сессий функцию start

Поменял конфиг на php
Прогнал профайлером
результаты не очень :(
Михалыч был прав - смарти зло, еще как выяснилось - симпла тоже зло, но меньшее :)
Вообще сильно тупит на инклудах библиотек - парсинг файлов смарти отнимает половину времени, если не выводится шаблон
При выводе шаблона смарти занимает >95 процентов времени, если не выводится было >50

пофиксил - теперь 404 отдается 150 раз в секунду
index с компонентами, функциями, и всем без коннекта к базе - 40
с коннектом к базе - 30, и это без прикрученного к базе кеширования :)
Правда <?php echo 1; ?> отдается 1200-1500 раз в секунду :(

Вырезал немного хлама из симплы, на pconnect не переводил.

Прикрутил различные шаблонизаторы, нужно допиливать PlainView
Вопрос в том, как сделать вызов из PlainView модуля, наверное нужно еще один способ передачи...

ОПИСАНИЕ ЧИТАТЬ ОТСЮДА: (вверху были наши мысли, переживания, чуства, детские комплексы, привычки нехорошие и все такое)

Описание:

В общем и целом:
Этот фреймворк представляет собой обьединение небольших библиотек и добавление того, чего им не хватает для создания крупных сайтов

Для отделения представления страницы от логики хорошо подходит smarty, можно было бы конечно написать свой шаблонизатор, но смарти хороший шаблонизатор, известный и часто используемый, а недостатков в нем довольно мало, причем некоторые исправляются этим фреймворком.

Для работы с базой данных тоже нужно что-то.
Была выбрана библиотека DbSimple которая известна посетителям сайта www.dklab.ru

Остается написать взаимодействие этих компонентов и разгребание url ака роутер и контроллеры :)
идея контроллеров взята с Зенда, но в отличае от него здесь отсутствует много не нужного.


Распишем структуру фреймворка и предлогаемые способы написания сайтов

Начнем со структуры папок
./tmp - название говорит само за себя - сюда будет складываться все, что нужно для работы
        - скомпиленные шаблоны смарти
        - кеш, если файловый
        - еще что-нить

./www - DocumentRoot - сюда будет класться статика и код, если не используются контроллеры
./application - здесь находятся модули, контроллеры и шаблоны.
в эти две папки вы пишете свой сайт :)

./library - здесь находится весь фреймворк

В папке ./application/ находятся папки модулей сайта в которых можно размещать.
Выбор контроллера для выполнения запроса происходит на основе адреса:
сначало проверяется наличие файла в /www - если там есть этот файл, то либо это статика, либо вы отказались использовать роутер, и это php файл, на него отдается управление и он выполняется (если он php)

Интересности начинаются когда файл в /www отсутствует
тогда URI разбивается по компонентам и пристально изучается :)

сначало из адреса выделяется модуль сайта - это первый компонент адреса и проверяется, существует ли папка этого модуля, если папка существует, то считается, что используется модуль по умолчанию - default, модули удобно использовать когда есть несколько почти не зависимых частей сайта, например сам сайт и админка, модулей по идее должно быть не много, небольшие сайты обходятся одним или двумя

в папке модуля папка controllers - оттуда и вызываются контроллеры, которыек определяются вторым компонентом адреса (хотя чаще первым, так как восносном используется контроллер default),.контроллер должен присутствовать, запрос /news/ выдаст ошибку если отсутствует файл /default/controllers/NewsController.php или /news/controllers/IndexController.php - контроллер Index подставляется по умолчанию, если адрес / или /[module]/

Следующий параметр определяет действие в классе контроллера, которое будет вызвано - по умолчанию indexAction все такие функции заканчиваются на Action

далее следуют параметры - есть два варианта передачи параметров - по имени и по позиции
при передачи по позиции вызов
module/control/action/p1/p2/p3/p4 
преобразуется в вызов функции
actionAction($p1,$p2,$p3,$p4) из контроллера control

при передаче параметров по имени первый параметр пустой - в адресе идут подрят два слеша
вызов
module/control/action//p1/z1/p2/z2/... 
преобразуется в вызов функции
actionAction() из контроллера control
с передачей ей первым параметром массива {p1=>z1,p2=>z2,...}
также параметры добавляются в массивы _GET и _REQUEST
и в случае нечетного количества оставщихся - значение последнего - пустая строка

при вызове функций и передаче параметров поддерживаются русские URL,
в частности по русски могут называться модули контроллеры и экшены

Идея контроллеров была взята из ZendFramework, но от MVC остался только контроллер :)

Для смарти был написан ресурс module - это компонент - как-бы маленькая страничка встроенная в другую.
для его пдключения в смарти пишется что-то похожее на 
{include file="module:module/control/action/p1/p2/p3"}
при этом управление передается функции actionModule из контроллера и модуля - правила формирования как в url
эта функция генерирует часть страницы так-же как и обычную страницу и результат вставляется в указанное место.

Такие инклуды удобны для активных блоков, например новостей, форм авторизации, пейдженаторов, погоду, сложное меню и прочее.
При вызове в двойных кавычках подставляются значения переменных, и тем самым можно передавать параметры.
Допускается произвольная вложенность и помещение их в любые шаблоны.

Пока при использовании модулей в компоненте должна присутствовать функция getTimestamp($action,$params) которая возвращает время, на которое можно закешировать обьект.
После того как будет приделан кешер функция будет не обязательна :)

В коде используются два глобальных обьекта - $view и $db - обьекты шаблонизатора и DbSimple - подключение к базе происходит только при необходимости, также есть встроенное кеширование (местами, частично прикрученное :).

Также для смарти написаны функции addCSS, addJS, getHead/outHead
addCSS и addJS добавляют подключение к страницам файлов JS и CSS, приэтом следят за уникальностью файлов
getHead/outHead захватывают контент и потом выводят его в указанное место

Настройка фреймворка:
в файле application/config/default.php указаны параметры модулей
также можно создать файл с именем $_SERVER['HTTP_HOST'] и расширением php для специфической конфигурации произвольного хоста
